---
layout:     post
title:      "第2章 模型评估与选择"
date:       1994-11-05
author:     "Ziven"
header-img: "img/in-post/zzh-machine-learning/bg.jpg"
header-mask:  0.3
catalog:      true
tags:
    - 学习笔记
    - 机器学习
---

返回[目录](http://ziven.xin/2017/07/06/zzh-machine-learning-outline/)   
---------------------------------------------------------------
用于查看完整数学公式：手机用户`长按公式`/PC用户`右击公式`出现菜单栏点击`Math Settings`--->`Zoom Trigger`--->`Double-Click`即可`双击放大`文中基于mathjax的公式与图表

## 重点：
本章主要讲的是如何去选择一个性能相对优良的机器学习模型(或学习器)。首先我们需要清楚什么样的学习器是好的学习器。
### 1. 什么是好的学习器
假设在\\(m\\)个样本中有\\(a\\)个样本分类错误，则：
错误率(error rate): \\(E=\frac{a}{m}\\)  

精度(accuracy): \\(1-E=(1-\frac{a}{m})\times\text{100%}\\)  

\\[
\text{误差(error)}
\begin{cases}
\text{在训练集上的误差}\longrightarrow\text{训练误差(training error)或经验误差(empirical error)}   \\\  
\text{在新样本上的误差}\longrightarrow\text{泛化误差(generalization error)}
\end{cases}
\\]
显然，我们希望得到泛化误差小的学习器，即将新样本输入到学习器中后得到的结果与真实的结果尽可能一样，但是我们并并不知道新样本会长什么样，因此，我们能做的就是最小化学习器的训练误差，但是是不是将训练误差降到最小，我们就能得到一个好的学习器呢？答案是否定的，我们需希望我们的学习器能够尽可能从训练样本中学出所有潜在样本的“普遍规律”或“共性”，这样当遇到新的样本时才能做出正确的判别。例如一个识别是否是马的二分类任务，我们希望通过训练集中各种不同的马的图片学得一个能够准确判别是否为马的学习器，我们希望这个学习器学习到的“普遍规律”是马的轮廓，而假设训练样本中有红马、黑马、棕马，当我们学得训练误差最小的学习器时，学习器可能学到了“深色”这个“个性”，这时，假如我们的新样本中出现了一匹白马，我们的学习器可能就会得出“白马非马”这个结论了，这种现象即为过拟合。
过拟合(overfitting):学习器把训练样本学得“太好”，把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，这样就会导致泛化性能下降。*即不仅拟合了训练样本的共性特征也过多地拟合了训练样本的个性特征，从而对未在训练样本中出现过新样本的预测能力很弱*   
但是如果训练误差太大的话，就会出现欠拟合的现象，比如识马任务中学习器只get到了“深色”这个点，那么给它输入一张黑猫的图片，它也会分类为马。
欠拟合(underfitting):对训练样本的一般性质尚未学好。*即对共性特征都没学好*  

因此，我们希望得到一个泛化误差小，即泛化能力强、对新样本适应能力强的学习器，但同时需要避免过拟合的问题。


### 2. 如何科学合理地使用数据集
既然我们知道了我们需要一个泛化误差小、对新样本适应能力强的学习器，但我们手头上只有有限的数据集，如果我们将整个数据集都用作训练，那么有可能出现过拟合的问题，但是如果我们那部分数据集用来训练，又有可能出现欠拟合的问题，那我们应该如何科学合理地使用我们手头上的数据集呢？

模型选择(model selection):使用一个“测试集(testing set)”来测试学习器对新样本的判别能力，然后以测试集上的“测试误差(testing error)”作为泛化误差的近似。   

若我们只有一个包含有\\(m\\)个样例的数据集\\(\\{(x_{1},y_{1}), (x_{2},y_{2}),\cdots,(x_{m},y_{m})\\}\\)，既要训练又要测试，怎样对学习的泛化误差进行评估并做出选择呢？我们可以通过对\\(D\\)进行适当的处理，从中产生出训练集\\(S\\)和测试集\\(T\\)的方法。    

#### 2.1 留出法(hold-out)
方法：  
直接将数据集\\(D\\)划分成两个互斥的集合*(训练/测试集的划分要尽可能保持数据分布的一致性，可以使用分层采样(stratified sampling))* ，其中一个集合作为训练集\\(S\\)，另一个集合作为测试集\\(T\\)   
\\[D=S\cup\text{T},\qquad\text{S}\cup\text{T}=\emptyset\\]

\\[
\begin{array}{cc}
\bbox[#A8F,5px,border:1px solid black]
{
  {
  \quad\quad\quad\quad\quad\text{数据集}D\quad\quad\quad\quad\quad
  }
}   \\\   
\downarrow  \\\   
\bbox[white,5px,border:1px solid black]
{
  {
    \\;\quad\quad\text{训练样本}S\quad\quad\\;\\,
  }
}
\bbox[#AFF,5px,border:1px solid black]
{
  {
  \text{测试样本}T\\,
  }
}
\end{array}
\\]   

单次使用留出法得到的估计结果往往不够可靠，在使用留出法时，一般要采用若干次随机划分，重复进行实验评估后取平均值作为留出法的评估结果。

#### 2.2 交叉验证法(cross validation)
> 又称\\(k\\)折交叉验证(\\(k\\)-fold cross validation)

方法：
1. 将数据集分为\\(k\\)个大小相似的互斥矩阵即\\(D=D_{1}\cup D_{2}\cup D_{3}\cdots\cup D_{k}, \quad D_{i}\cap D_{j}=\emptyset(i\neq j)\\)。  
每个子集\\(D_{i}\\)都尽可能保持数据分布的一致性。(图中\\(k=10\\))
  ![10折交叉验证示意图1](/img/in-post/zzh-machine-learning/ch2/10-fold_cross_validation1.png)
2. 每次用\\(k-1\\)个子集的并集作为训练集，余下的那个子集作为测试集。
3. 获得\\(k\\)组训练/测试集，从而进行\\(k\\)次训练和测试。
4. 将\\(k\\)个测试结果的均值作为最终结果。
  ![10折交叉验证示意图2](/img/in-post/zzh-machine-learning/ch2/10-fold_cross_validation2.png)
5. 为了减小因样本划分不同而引入的差别，\\(k\\)折交叉验证通常需要随机使用不同的划分重复\\(p\\)次。
6. 最终的评估结果是这\\(p\\)次\\(k\\)折交叉验证结果的均值。

留一法(Leave-One-Out,简称LOO)：
假定数据集包含\\(m\\)个样本，若令\\(k=m\\)，则在\\(k\\)折交叉验证中训练集由\\(m-1\\)个样本组成，而测试集只有一个样本。
* 优点：评估结果准确
* 缺点：当数据集过大时，计算开销大

#### 2.3 自助法(bootstrapping)
方法：  
以自助采样(bootstrap sampling)为基础，假设给定包含\\(m\\)个样本的数据集\\(D\\)，对其拷贝放入\\(D'\\)。
1. 每次随机从\\(D\\)中挑选一个样本，将其`拷贝`放入\\(D'\\)。
2. 将步骤1重复执行\\(m\\)次，此时我们得到了包含\\(m\\)个样本的数据集\\(D'\\)。
3. 将数据集\\(D'\\)用作训练集，\\(D\setminus D'\\)*(“\\(\setminus\\)”为集合减法，\\(D\\)中有而\\(D'\\)中没有的样本)* 用作测试集。  

这样的测试结果亦称包外估计(out-of-bag estimate)。

`自助法`在数据集较小，难以有效划分训练/测试集时很有用；而在初始数据量足够多时，`留出法`和`交叉验证法`更常用一些。

#### 2.4 调参与最终模型
当我们分割好数据集输入到学习器后，还需要进行调参才能得到最终的模型。
机器学习常涉及两种参数：
* 算法的参数：亦称“超参数”，数目常在10以内，通常由人工设定多个参数候选值后产生模型 *(如梯度下降中的learning rate)*
* 模型的参数：数目可能很多，通过学习来产生多个候选模型 *(如全连接神经网络中的weights)*

### 3. 衡量模型泛化能力的评价标准
那么我们如何才能知道我们调参过后得到的学习器就是泛化能力强的好学习器呢？因此，我们还需要有衡量模型泛化能力的评价标准，即性能度量(performance measure)
性能度量反应了任务需求，在对比不同模型的能力时，使用不同的性能度量往往会导致不同的评判结果；这意味着模型的“好坏”是相对的，什么样的模型是好的，不仅取决于算法和数据，还决定于`任务需求`。
在预测任务中，给定样例集\\(D=\\{(X_{1},Y_{1}),(X_{2,Y_{2}}),\cdots,(x_{m},y_{m})\\}\\)，其中\\(y_{i}\\)是示例\\(x_{i}\\)的真实标记，要评估学习器\\(f\\)的性能，就要把学习器预测结果\\(f(x)\\)与真实标记\\(y\\)进行比较。

#### 3.1 回归任务中常用的性能度量
回归任务中最常用的性能度量是均方误差(mean squared error)，其公式为：
\\[E(f;D)=\frac{1}{m}\sum_{i=1}^m (f(x_i)-y_{i})^2\\]
更一般的，对于数据分布\\(\mathcal{D}\\)和概率密度函数\\(p(\cdot)\\)，均方误差可描述为：
\\[E(f;\mathcal{D})=\int_{x\sim\mathcal{D}} (f(x)-y)^2 p(x)dx\\]

#### 3.2 分类任务中常用的性能度量
1. 错误率与精度：
  对于样例集\\(D\\)，分类错误率定义为：
  \\[E(f;D)=\frac{1}{m}\sum_{i=1}^{m} \mathbb{I}(f(x_{i}\neq y_{i}))\\]
  其中\\(\mathbb{I}(\cdot)\\)为指示函数
  \\[\mathbb{I}(\cdot)=\begin{cases}0\quad\cdot为假 \\\ 1\quad\cdot为真\end{cases}\\]
  精度定义为：
  \\[\begin{align}
    acc(f;D) & =  \frac{1}{m}\sum_{i=1}^{m} \mathbb{I}(f(x_{i})=y_{i})  \\\  
    & =  1-E(f;D)
  \end{align}
  \\]
  更一般的，对于数据分布\\(\mathcal{D}\\)和概率密度函数\\(p(\cdot)\\)，错误率和精准率可描述为：
  \\[E(f;\mathcal{D})=\int_{x\sim\mathcal{D}} \mathbb{I}(f(x)\neq y) p(x)dx\\, ,\\]
  \\[\begin{align}
    acc(f;\mathcal{D}) & =  \int_{x\sim\mathcal{D}} \mathbb{I}(f(x)=y) p(x)dx  \\\  
    & =  1-E(f;\mathcal{D})\\, .
  \end{align}
  \\]
